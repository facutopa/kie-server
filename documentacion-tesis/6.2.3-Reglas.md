# 6.2.3 Reglas

## 6.2.3.1 Arquitectura del Sistema de Reglas

El sistema experto para diagnóstico de porfiria implementa un conjunto de reglas organizadas en categorías médicas específicas, siguiendo un esquema modular que permite mayor flexibilidad y mantenibilidad. La división de reglas por categorías clínicas, basada en los diferentes tipos de síntomas y factores de riesgo, se mantiene durante la instanciación de reglas.

### 6.2.3.1.1 Estructura de Clases de Reglas

Cada categoría de reglas contiene métodos que definen las condiciones a cumplir y las acciones a realizar. Estos métodos reciben una instancia de la clase `Patient` para acceder a sus datos clínicos y respuestas del cuestionario, así como una referencia al objeto `CuadroClinico` que se está generando para el diagnóstico.

La Figura 6.8 ejemplifica la implementación de una regla de puntuación para síntomas cutáneos del sistema de diagnóstico de porfiria.

```java
/*
 * REG-001 - Máculas
 * Categoría: Síntomas Cutáneos
 * Puntuación: +2 puntos
 */
rule "REG-001 - Máculas"
    when
        $patient: Patient()
        $cuadro: CuadroClinico(patientId == $patient.id)
        $response: QuestionnaireResponse(questionId == "maculas", answer == "SI")
    then
        double nuevosPuntos = $cuadro.getSintomasCutanea() + 2;
        $cuadro.setSintomasCutanea(nuevosPuntos);
        update($cuadro);
end
```

### 6.2.3.1.2 Categorías de Reglas

El sistema implementa tres categorías principales de reglas:

1. **Reglas de Síntomas Cutáneos (REG-001 a REG-012)**: Evalúan manifestaciones dermatológicas
2. **Reglas de Síntomas Agudos (REG-013 a REG-029)**: Evalúan manifestaciones neurológicas y sistémicas
3. **Reglas de Anamnesis (REG-030 a REG-049)**: Evalúan factores de riesgo y antecedentes

### 6.2.3.1.3 Reglas de Diagnóstico

Las clases del paquete `DiagnosticoTemprano` no solo trabajan con las puntuaciones acumuladas, sino que también instancian diagnósticos permitidos para cada paciente basándose en los umbrales establecidos y las puntuaciones obtenidas.

Cada paquete incluye una clase generadora de reglas y funciones responsables de crear reglas basadas en las condiciones proporcionadas. La Figura 6.9 ilustra el diseño de clases agrupadas por paquete.

## 6.2.3.2 Implementación de Reglas por Categoría

### 6.2.3.2.1 Reglas de Síntomas Cutáneos

Las reglas de síntomas cutáneos evalúan manifestaciones dermatológicas específicas de la porfiria. Cada síntoma tiene asignada una puntuación según su relevancia diagnóstica:

```java
/*
 * REG-010 - Fotosensibilidad
 * Categoría: Síntomas Cutáneos
 * Puntuación: +5 puntos (alta relevancia diagnóstica)
 */
rule "REG-010 - Fotosensibilidad"
    when
        $patient: Patient()
        $cuadro: CuadroClinico(patientId == $patient.id)
        $response: QuestionnaireResponse(questionId == "fotosensibilidad", answer == "SI")
    then
        double nuevosPuntos = $cuadro.getSintomasCutanea() + 5;
        $cuadro.setSintomasCutanea(nuevosPuntos);
        update($cuadro);
end
```

### 6.2.3.2.2 Reglas de Síntomas Agudos

Las reglas de síntomas agudos evalúan manifestaciones neurológicas y sistémicas que pueden indicar crisis porfírica:

```java
/*
 * REG-014 - Parestesias
 * Categoría: Síntomas Agudos
 * Puntuación: +5 puntos (alta relevancia diagnóstica)
 */
rule "REG-014 - Parestesias"
    when
        $patient: Patient()
        $cuadro: CuadroClinico(patientId == $patient.id)
        $response: QuestionnaireResponse(questionId == "parestesias", answer == "SI")
    then
        double nuevosPuntos = $cuadro.getSintomasAguda() + 5;
        $cuadro.setSintomasAguda(nuevosPuntos);
        update($cuadro);
end
```

### 6.2.3.2.3 Reglas de Anamnesis

Las reglas de anamnesis evalúan factores de riesgo y antecedentes familiares que pueden predisponer a la porfiria:

```java
/*
 * REG-031 - Familiares
 * Categoría: Anamnesis
 * Puntuación: +5 puntos (alta relevancia diagnóstica)
 */
rule "REG-031 - Familiares"
    when
        $patient: Patient()
        $cuadro: CuadroClinico(patientId == $patient.id)
        $response: QuestionnaireResponse(questionId == "familiares", answer == "SI")
    then
        double nuevosPuntos = $cuadro.getAnamnesis() + 5;
        $cuadro.setAnamnesis(nuevosPuntos);
        update($cuadro);
end
```

## 6.2.3.3 Reglas de Diagnóstico y Generación de Órdenes

### 6.2.3.3.1 Reglas de Determinación de Sintomatología

El sistema incluye reglas específicas para determinar el tipo de sintomatología predominante:

```java
/*
 * REG-050 - Determinar Sintomatología Aguda
 * Umbral: ≥ 36 puntos en síntomas agudos
 */
rule "REG-050 - Determinar Sintomatología Aguda"
    when
        $patient: Patient()
        $diagnostico: DiagnosticoTemprano(patientId == $patient.id)
        $cuadro: CuadroClinico(patientId == $patient.id, $cuadro.getSintomasAguda() >= 36)
    then
        $diagnostico.setSintomaCutanea(false);
        $diagnostico.setSintomaAguda(true);
        update($diagnostico);
end
```

### 6.2.3.3.2 Reglas de Generación de Órdenes

El sistema genera automáticamente órdenes de estudios complementarios cuando se detecta sintomatología relevante:

```java
/*
 * REG-052 - Ordenar Estudios
 * Se activa cuando se detecta sintomatología cutánea o aguda
 */
rule "REG-052 - Ordenar Estudios"
    when
        $patient: Patient()
        $diagnostico: DiagnosticoTemprano(patientId == $patient.id, sintomaAguda == true || sintomaCutanea == true)
        not GenerarOrden(patientId == $patient.id)
    then   
        GenerarOrden orden = new GenerarOrden();
        orden.setPatientId($patient.getId());
        orden.setEstudios(true);
        insert(orden);
end
```

## 6.2.3.4 Sistema de Puntuación

### 6.2.3.4.1 Umbrales Diagnósticos

El sistema utiliza umbrales específicos para determinar la presencia de sintomatología:

- **Síntomas Cutáneos**: Umbral ≥ 22 puntos
- **Síntomas Agudos**: Umbral ≥ 36 puntos
- **Anamnesis**: Puntuación acumulativa para factores de riesgo

### 6.2.3.4.2 Escala de Puntuación

Las reglas implementan una escala de puntuación que refleja la relevancia diagnóstica de cada síntoma:

- **+5 puntos**: Síntomas altamente específicos (fotosensibilidad, parestesias, ampollas)
- **+4 puntos**: Síntomas muy relevantes (hipertricosis, trastornos psiquiátricos)
- **+3 puntos**: Síntomas moderadamente relevantes (costras, cefaleas)
- **+2 puntos**: Síntomas de relevancia media (máculas, pruritos)
- **+1 punto**: Síntomas de baja relevancia (nódulos, lesiones oculares)
- **+0.5 puntos**: Factores de riesgo menores (diabetes, HTA)

## 6.2.3.5 Reglas de Medicamentos Contraproducentes

El sistema incluye reglas específicas para informar sobre medicamentos que pueden agravar la porfiria:

```java
/*
 * REG-053 - Informar Medicamentos Contraproducentes
 * Se activa cuando se detecta sintomatología aguda
 */
rule "REG-053 - Informar Medicamentos Contraproducentes"
    when
        $patient: Patient()
        $diagnostico: DiagnosticoTemprano(patientId == $patient.id, sintomaAguda == true)
    then
        InformarWeb informar = new InformarWeb();
        informar.setPatientId($patient.getId());
        informar.setMedicamentos(true);
        insert(informar);
end
```

## 6.2.3.6 Ventajas del Diseño Modular

La implementación modular de reglas ofrece las siguientes ventajas:

1. **Mantenibilidad**: Cada categoría de reglas puede ser modificada independientemente
2. **Escalabilidad**: Nuevas reglas pueden ser agregadas sin afectar las existentes
3. **Trazabilidad**: Cada regla tiene un identificador único (REG-XXX) para seguimiento
4. **Flexibilidad**: Los umbrales y puntuaciones pueden ser ajustados según nuevos conocimientos médicos
5. **Auditabilidad**: El sistema permite rastrear qué reglas se activaron para cada diagnóstico

Este diseño modular facilita la actualización del sistema con nuevos conocimientos médicos y permite la personalización de umbrales según las necesidades específicas de cada centro médico.

## 6.2.3.7 Motor de Reglas y Arquitectura del Sistema

### 6.2.3.7.1 Funcionamiento del Motor de Reglas

El motor de reglas Drools constituye el núcleo del sistema experto, encargándose de la evaluación automática de las condiciones médicas y la aplicación de la lógica de diagnóstico. El motor opera mediante un ciclo de inferencia que procesa los hechos (datos del paciente) contra las reglas definidas, generando nuevas conclusiones y actualizando el estado del conocimiento.

El funcionamiento del motor de reglas se basa en un paradigma de programación declarativa donde el conocimiento médico se expresa mediante reglas del tipo "si-entonces" (if-then). Cuando un paciente ingresa al sistema a través del frontend web, sus datos se transforman en hechos que son insertados en la base de hechos del motor. Esta base de hechos actúa como un repositorio dinámico que contiene toda la información disponible sobre el paciente, incluyendo sus datos personales, respuestas al cuestionario médico, y los objetos generados durante el proceso de evaluación.

El ciclo de inferencia comienza con la inicialización del motor, donde se cargan todas las reglas definidas en el archivo `reglas.drl`. Estas reglas representan el conocimiento médico codificado, desde la evaluación de síntomas cutáneos hasta la determinación de diagnósticos y la generación de recomendaciones. Una vez cargadas las reglas, el motor procede a insertar los hechos del paciente en la base de hechos, creando una representación computacional del estado clínico del individuo.

El proceso de evaluación se desarrolla mediante un algoritmo de pattern matching que compara cada regla contra los hechos disponibles en la base de conocimiento. Cuando una regla encuentra que sus condiciones se cumplen con los datos del paciente, se marca para ejecución en la agenda de activación. Por ejemplo, si un paciente reporta fotosensibilidad en el cuestionario, la regla REG-010 se activa automáticamente, incrementando la puntuación de síntomas cutáneos en cinco puntos.

La ejecución de las reglas activadas sigue un orden de prioridad que garantiza la coherencia del diagnóstico. Las reglas de puntuación se ejecutan primero, acumulando puntos según los síntomas reportados. Posteriormente, las reglas de diagnóstico evalúan los umbrales alcanzados para determinar el tipo de sintomatología predominante. Finalmente, las reglas de generación de órdenes y recomendaciones se activan para proporcionar las acciones clínicas apropiadas.

Durante todo este proceso, el motor mantiene un estado consistente de la base de hechos, actualizando los objetos conforme se ejecutan las reglas. El objeto `CuadroClinico` evoluciona dinámicamente, acumulando puntuaciones en las diferentes categorías de síntomas. El objeto `DiagnosticoTemprano` se actualiza cuando se alcanzan los umbrales diagnósticos, estableciendo el tipo de porfiria detectada. Los objetos `GenerarOrden` e `InformarWeb` se crean automáticamente cuando las condiciones clínicas lo requieren.

El ciclo de inferencia continúa iterativamente hasta que no hay más reglas que puedan activarse, garantizando que todas las conclusiones posibles se extraigan de los datos disponibles. Este proceso asegura que el diagnóstico sea completo y coherente, considerando todas las interacciones posibles entre los síntomas y factores de riesgo del paciente.

### 6.2.3.7.2 Arquitectura de Integración con la API

El sistema implementa una arquitectura de tres capas que permite la integración fluida entre el motor de reglas y el frontend web. Esta arquitectura está diseñada para proporcionar una separación clara de responsabilidades, donde cada capa tiene un propósito específico en el procesamiento de la información médica.

La capa de presentación está representada por el frontend web, que proporciona una interfaz intuitiva para que los profesionales de la salud ingresen los datos del paciente y visualicen los resultados del diagnóstico. Esta interfaz incluye formularios estructurados que capturan la información clínica necesaria, desde datos demográficos básicos hasta respuestas detalladas sobre síntomas y antecedentes familiares. El frontend también presenta los resultados del diagnóstico de manera clara y comprensible, incluyendo visualizaciones de las puntuaciones obtenidas, el tipo de sintomatología detectada, y las recomendaciones clínicas generadas.

La capa de controladores REST actúa como el punto de entrada para todas las comunicaciones entre el frontend y el backend. Los controladores `PorfiriaController` y `PorfiriaInfoController` manejan las peticiones HTTP, validan los datos de entrada, y coordinan la comunicación con la capa de servicios. Estos controladores implementan endpoints RESTful que permiten al frontend enviar datos del paciente para evaluación y consultar el estado del diagnóstico en tiempo real.

La capa de servicios contiene la lógica de negocio del sistema, siendo el `DroolsService` el componente central que orquesta la interacción con el motor de reglas. Este servicio se encarga de inicializar las sesiones del motor Drools, insertar los hechos del paciente en la base de conocimiento, ejecutar el ciclo de inferencia, y procesar los resultados generados. El servicio también maneja la persistencia de los resultados y la comunicación con la base de datos para almacenar el historial de diagnósticos.

La capa de modelo de datos proporciona la representación computacional de los conceptos médicos utilizados en el sistema. Los objetos `Patient`, `CuadroClinico`, `DiagnosticoTemprano`, `GenerarOrden`, e `InformarWeb` encapsulan la información clínica y los resultados del diagnóstico, permitiendo que el motor de reglas opere sobre una representación estructurada del conocimiento médico.

```
┌─────────────────────────────────────────────────────────────┐
│                    FRONTEND WEB                            │
│  ┌─────────────────┐  ┌─────────────────┐                │
│  │   Formulario    │  │   Resultados    │                │
│  │   Cuestionario  │  │   Diagnóstico   │                │
│  └─────────────────┘  └─────────────────┘                │
└─────────────────────────────────────────────────────────────┘
                              │
                              │ HTTP/REST API
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    CONTROLADOR REST                        │
│  ┌─────────────────┐  ┌─────────────────┐                │
│  │ PorfiriaController │ PorfiriaInfoController │        │
│  │   /api/porfiria  │  │ /api/porfiria/info │           │
│  └─────────────────┘  └─────────────────┘                │
└─────────────────────────────────────────────────────────────┘
                              │
                              │ Service Layer
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    SERVICIO DE REGLAS                      │
│  ┌─────────────────┐  ┌─────────────────┐                │
│  │  DroolsService  │  │  Configuración  │                │
│  │   Motor Drools  │  │   DroolsConfig  │                │
│  └─────────────────┘  └─────────────────┘                │
└─────────────────────────────────────────────────────────────┘
                              │
                              │ Base de Hechos
                              ▼
┌─────────────────────────────────────────────────────────────┐
│                    MODELO DE DATOS                         │
│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐          │
│  │   Patient   │ │CuadroClinico│ │DiagnosticoTemprano│    │
│  └─────────────┘ └─────────────┘ └─────────────┘          │
└─────────────────────────────────────────────────────────────┘
```

### 6.2.3.7.3 Flujo de Interacción Frontend-Motor de Reglas

**Paso 1: Recepción de Datos del Frontend**
```java
@RestController
@RequestMapping("/api/porfiria")
public class PorfiriaController {
    
    @PostMapping("/evaluar")
    public ResponseEntity<Map<String, Object>> evaluarPaciente(
            @RequestBody Patient patient) {
        
        // El controlador recibe los datos del formulario web
        // y los prepara para el motor de reglas
        return droolsService.evaluarPaciente(patient);
    }
}
```

**Paso 2: Procesamiento en el Motor de Reglas**
```java
@Service
public class DroolsService {
    
    public Map<String, Object> evaluarPaciente(Patient patient) {
        // 1. Inicializar la sesión del motor de reglas
        KieSession kieSession = kieContainer.newKieSession();
        
        // 2. Insertar el paciente en la base de hechos
        kieSession.insert(patient);
        
        // 3. Insertar las respuestas del cuestionario
        for (QuestionnaireResponse response : patient.getResponses()) {
            kieSession.insert(response);
        }
        
        // 4. Ejecutar el motor de reglas
        int rulesFired = kieSession.fireAllRules();
        
        // 5. Recuperar los resultados generados
        List<Object> results = new ArrayList<>();
        for (Object fact : kieSession.getObjects()) {
            if (fact instanceof CuadroClinico || 
                fact instanceof DiagnosticoTemprano ||
                fact instanceof GenerarOrden ||
                fact instanceof InformarWeb) {
                results.add(fact);
            }
        }
        
        // 6. Cerrar la sesión
        kieSession.dispose();
        
        // 7. Retornar resultados al frontend
        return procesarResultados(results);
    }
}
```

**Paso 3: Respuesta al Frontend**
```java
private Map<String, Object> procesarResultados(List<Object> results) {
    Map<String, Object> response = new HashMap<>();
    
    // Buscar el cuadro clínico generado
    CuadroClinico cuadro = results.stream()
        .filter(CuadroClinico.class::isInstance)
        .map(CuadroClinico.class::cast)
        .findFirst()
        .orElse(null);
    
    // Buscar el diagnóstico temprano
    DiagnosticoTemprano diagnostico = results.stream()
        .filter(DiagnosticoTemprano.class::isInstance)
        .map(DiagnosticoTemprano.class::cast)
        .findFirst()
        .orElse(null);
    
    // Construir respuesta estructurada para el frontend
    response.put("cuadroClinico", cuadro);
    response.put("diagnostico", diagnostico);
    response.put("recomendaciones", generarRecomendaciones(diagnostico));
    
    return response;
}
```

### 6.2.3.7.4 Comunicación Asíncrona y Tiempo Real

El sistema implementa un patrón de comunicación asíncrona que permite al frontend recibir actualizaciones en tiempo real sobre el progreso del diagnóstico:

**Endpoint de Información en Tiempo Real:**
```java
@GetMapping("/info/{patientId}")
public ResponseEntity<Map<String, Object>> obtenerInformacionPaciente(
        @PathVariable String patientId) {
    
    // El frontend puede consultar periódicamente este endpoint
    // para obtener actualizaciones del estado del diagnóstico
    Map<String, Object> info = droolsService.obtenerEstadoDiagnostico(patientId);
    return ResponseEntity.ok(info);
}
```

### 6.2.3.7.5 Manejo de Estados y Persistencia

El motor de reglas mantiene el estado de cada evaluación a través de objetos persistentes que permiten al frontend consultar el progreso del diagnóstico:

```java
// Estado inicial del paciente
Patient patient = new Patient();
patient.setId("P001");
patient.setName("Juan Pérez");

// El motor de reglas genera automáticamente:
// 1. CuadroClinico - Puntuaciones acumuladas
// 2. DiagnosticoTemprano - Tipo de sintomatología detectada
// 3. GenerarOrden - Órdenes de estudios necesarios
// 4. InformarWeb - Medicamentos contraproducentes
```

### 6.2.3.7.6 Integración con Base de Datos

El sistema persiste los resultados del motor de reglas para permitir consultas históricas y auditoría:

```java
// Los resultados del motor se almacenan automáticamente
@Transactional
public void persistirResultados(Patient patient, List<Object> resultados) {
    // Persistir cuadro clínico
    cuadroClinicoRepository.save(cuadro);
    
    // Persistir diagnóstico
    diagnosticoRepository.save(diagnostico);
    
    // Persistir órdenes generadas
    ordenRepository.save(orden);
    
    // Registrar auditoría
    auditoriaService.registrarEvaluacion(patient.getId(), resultados);
}
```

### 6.2.3.7.7 Optimización del Motor de Reglas

El sistema implementa varias optimizaciones para garantizar un rendimiento óptimo del motor de reglas, considerando las particularidades del dominio médico y los requisitos de tiempo real para el diagnóstico. Estas optimizaciones se han diseñado específicamente para manejar la complejidad computacional inherente a la evaluación de múltiples síntomas y la aplicación de reglas médicas complejas.

El sistema de caché de sesiones representa una optimización fundamental que permite reutilizar sesiones del motor Drools para consultas similares, reduciendo significativamente el tiempo de inicialización y la sobrecarga computacional. Cuando múltiples pacientes presentan patrones de síntomas similares, el sistema puede aprovechar sesiones previamente configuradas, acelerando el proceso de evaluación. Esta estrategia es especialmente efectiva en entornos clínicos donde se evalúan pacientes con condiciones relacionadas o durante períodos de alta demanda.

La implementación de lazy loading permite que el motor cargue reglas de manera diferida según el contexto específico del paciente, evitando la carga innecesaria de reglas que no son relevantes para el caso particular. Por ejemplo, si un paciente no presenta síntomas cutáneos, el sistema no carga las reglas específicas para evaluación dermatológica, optimizando el uso de memoria y reduciendo el tiempo de procesamiento. Esta aproximación es particularmente valiosa en el contexto médico, donde diferentes tipos de porfiria requieren diferentes conjuntos de reglas.

El filtrado inteligente de reglas representa una optimización avanzada que activa selectivamente las reglas según el tipo de sintomatología detectada en las primeras etapas de la evaluación. El sistema analiza los síntomas iniciales reportados por el paciente y determina qué categorías de reglas son relevantes, evitando la evaluación de reglas irrelevantes. Esta estrategia no solo mejora el rendimiento, sino que también reduce la posibilidad de falsos positivos al enfocar la evaluación en las áreas más relevantes del conocimiento médico.

El procesamiento en lotes (batch processing) permite al sistema manejar múltiples pacientes simultáneamente, optimizando el uso de recursos computacionales y mejorando el throughput del sistema. Esta capacidad es especialmente importante en entornos hospitalarios donde se pueden evaluar múltiples pacientes en paralelo, permitiendo que el sistema mantenga un rendimiento consistente incluso bajo cargas de trabajo intensas.

### 6.2.3.7.8 Monitoreo y Logging

El sistema incluye capacidades avanzadas de monitoreo para el seguimiento del rendimiento del motor de reglas, proporcionando visibilidad completa sobre el funcionamiento interno del sistema experto. Estas capacidades de monitoreo son esenciales para garantizar la confiabilidad del diagnóstico médico y permitir la auditoría de las decisiones tomadas por el sistema.

El sistema de monitoreo implementa un patrón de eventos que captura cada interacción significativa entre el motor de reglas y los datos del paciente. Cuando una regla se activa durante el proceso de diagnóstico, el sistema genera un evento `ReglaActivadaEvent` que contiene información detallada sobre la regla ejecutada, el paciente involucrado, y el contexto clínico que llevó a su activación. Este evento se registra en el sistema de logging con un nivel de detalle apropiado, permitiendo a los administradores del sistema y al personal médico rastrear el razonamiento seguido por el motor de reglas.

El monitoreo de rendimiento se extiende más allá del simple logging de eventos, incluyendo métricas detalladas sobre el tiempo de ejecución de cada regla, el número de reglas activadas por diagnóstico, y la eficiencia del motor en diferentes escenarios clínicos. Estas métricas se almacenan en una base de datos de monitoreo que permite análisis estadísticos del rendimiento del sistema y la identificación de patrones en el uso de las reglas médicas.

El sistema también implementa alertas automáticas que notifican a los administradores cuando se detectan anomalías en el funcionamiento del motor de reglas, como tiempos de ejecución inusualmente largos, reglas que se activan con mayor frecuencia de lo esperado, o patrones de diagnóstico que se desvían significativamente de las expectativas clínicas. Estas alertas permiten una respuesta rápida a problemas potenciales y garantizan la integridad del sistema de diagnóstico.

La auditoría de decisiones representa un componente crítico del sistema de monitoreo, registrando cada paso del proceso de diagnóstico para permitir la revisión posterior por parte de expertos médicos. Esta funcionalidad es especialmente importante en el contexto médico, donde la trazabilidad de las decisiones diagnósticas es fundamental para la calidad de la atención y el cumplimiento de regulaciones médicas.

```java
@Component
public class ReglasMonitor {
    
    @EventListener
    public void onReglaActivada(ReglaActivadaEvent event) {
        logger.info("Regla activada: {} para paciente: {}", 
                   event.getReglaId(), event.getPatientId());
        
        // Métricas de rendimiento
        metricasService.registrarActivacionRegla(event);
    }
    
    @EventListener
    public void onDiagnosticoCompletado(DiagnosticoCompletadoEvent event) {
        logger.info("Diagnóstico completado para paciente: {} en {}ms", 
                   event.getPatientId(), event.getTiempoEjecucion());
    }
}
```

Esta arquitectura garantiza que el motor de reglas funcione como un sistema robusto y escalable, proporcionando diagnósticos precisos y oportunos a través de una interfaz web intuitiva y responsiva.
